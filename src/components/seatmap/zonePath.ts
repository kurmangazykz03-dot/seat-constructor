const toRad = (deg: number) => (deg * Math.PI) / 180;
const clamp = (v: number, lo: number, hi: number) => Math.max(lo, Math.min(hi, v));

/**
 * Строит путь клиновидной фигуры (path для <path d="...">) по ширине/высоте и двум углам.
 *
 * — Верхняя грань клина всегда остаётся в пределах [0..w].
 * — Устойчиво работает при углах, близких к 0°/180° (нет деления на 0).
 *
 * @param w         ширина прямоугольника
 * @param h         высота прямоугольника
 * @param angleLeftDeg   угол наклона левого луча (из нижнего левого угла, в градусах)
 * @param angleRightDeg  угол наклона правого луча (из нижнего правого угла, в градусах)
 * @param minTop    минимальная ширина верхнего основания (чтобы верх не схлопывался в точку)
 */
export function buildAngleWedgePathClamped(
  w: number,
  h: number,
  angleLeftDeg: number,
  angleRightDeg: number,
  minTop = 24 // ⬅️ минимально допустимая ширина верхней стороны
) {
  // Локальный перевод градусов в радианы
  const toRad = (d: number) => (d * Math.PI) / 180;

  /**
   * "Безопасный" cot(угла) = cos/sin.
   * Если sin(a) ≈ 0 (угол почти 0° или 180°) — возвращаем очень большое число,
   * чтобы не делить на 0 и не получить бесконечность.
   */
  const safeCot = (a: number) => {
    const s = Math.sin(a);
    const c = Math.cos(a);
    if (Math.abs(s) < 1e-6) {
      // почти вертикальный луч → считаем, что dx очень большой
      return c >= 0 ? 1e12 : -1e12;
    }
    return c / s;
  };

  // Сдвиг верхней точки слева: на сколько пикселей вправо уйдёт пересечение луча с верхом
  let dxL = h * safeCot(toRad(angleLeftDeg));
  // Сдвиг верхней точки справа: на сколько пикселей влево от правого края
  let dxR = h * safeCot(toRad(angleRightDeg));

  // Жёстко ограничиваем dx в пределах ширины [0..w-1], чтобы не "выстрелить" за край
  dxL = Math.max(0, Math.min(dxL, w - 1));
  dxR = Math.max(0, Math.min(dxR, w - 1));

  // Максимально допустимая сумма смещений, чтобы верхняя сторона не была уже minTop
  const maxSum = Math.max(0, w - minTop);
  const sum = dxL + dxR;

  // Если суммарный "сдвиг" превышает допустимый, пропорционально уменьшаем оба dx
  if (sum > maxSum) {
    const k = maxSum / (sum || 1); // защита от деления на 0, если sum вдруг == 0
    dxL *= k;
    dxR *= k;
  }

  // Координаты верхних точек клина:
  // TLx — X левой верхней точки (отступ от левого края)
  // TRx — X правой верхней точки (от правого края уходим на dxR)
  const TLx = dxL;
  const TRx = w - dxR;

  // Возвращаем SVG-path: идём по часовой стрелке
  // (0,h) — нижний левый, (w,h) — нижний правый, (TRx,0) — верхний правый, (TLx,0) — верхний левый
  return `M 0 ${h} L ${w} ${h} L ${TRx} 0 L ${TLx} 0 Z`;
}
